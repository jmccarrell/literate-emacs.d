#+TITLE: Emacs Configuration
#+AUTHOR: Jeff McCarrell
#+EMAIL: jeff@mccarrell.org
#+STARTUP: showeverything
#+PROPERTY: header-args:emacs-lisp  :tangle "init.el"

* Introduction
** About This File

   After many years of emacs evolution via hunting and pecking, I finally refactored my existing emacs setup
   in the literate style. I continue to follow the lead of many fine emacs devotees, among them:

   - [[https://github.com/howardabrams/dot-files/blob/master/emacs.org][Howard Abrams]]
   - [[https://github.com/sachac/.emacs.d][Sacha Chua]]
   - [[https://github.com/danielmai/.emacs.d][Daniel Mai]]
   - [[https://www.wisdomandwonder.com/tag/emacs][Grant aka Wisdom and Wonder]]
   - [[https://github.com/jwiegley/dot-emacs][John Weigley]]
   - [[https://github.com/purcell/emacs.d][Steve Purcell]]
   - [[https://github.com/abo-abo/oremacs][abo-abo]]
   - [[https://github.com/NicolasPetton/emacs.d][Nicolas Petton]]
   - [[https://gitlab.com/protesilaos/dotfiles][Protesilaos Stavrou]]
     - Prot's [[https://protesilaos.com/codelog/][coding blog]]
   - and many others

   To all of these contributors, I doff my cap in salute. Your published work has inspired and -- to be honest
   -- at times terrified me as I have contemplated cutting and splicing together these various styles in search
   of my own.

   I would also like to publicly acknowledge certain emacs contributors of the YouTube genre, among them:

   - [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][Ranier König]]
   - [[https://www.youtube.com/channel/UClT2UAbC6j7TqOWurVhkuHQ][Sacha Chua]]
   - [[https://www.youtube.com/playlist?list=PL9KxKa8NpFxIcNQa9js7dQQIHc81b0-Xg][Mike Zamansky]]
     - [[https://cestlaz.github.io/stories/emacs/][blog series]]
   - [[https://www.youtube.com/user/howardabrams/videos][Howard Abrams]]
   - [[https://www.youtube.com/playlist?list=PL0sMmOaE_gs3GbuZV_sNjwMREw9rfElTV][John Kitchen]]
   - [[https://www.youtube.com/channel/UCCRdRbI93UGW0AZttVH3SbA/feed][Daniel Gopar]]
   - [[https://www.youtube.com/watch?v=gfZDwYeBlO4&t=4101s][Alain M. Lafon]]

   I have drawn inspiration to adopt new ways of doing some very old tricks from these fine folks.

   In this refactor, I have the following major goals:

   - create a more functional emacs leveraging recent innovation
   - KISS: smaller is better; only add where there is significant reason to
   - use the literate programming style
     - learn babel and tangle in the process
   - learn more emacs-lisp; even become competent?
   - add ivy, swiper and counsel in addition to -- or perhaps replace? -- helm
     - it turns out I have chosen to replace helm with ivy, avy, swiper and counsel.

   as well as a host of smaller, clean-up type goals.

** Which emacs on Mac OS X?

   Circa summer 2019, I prefer [[https://emacsformacosx.com/][GNU Emacs for Mac OS X]] installed by homebrew.

   #+BEGIN_SRC shell
     brew cask install emacs
   #+END_SRC

   This installs emacs and emacsclient, which provide my emacs foundation.

   I *always* invoke emacs from the iterm shell, so it will inherit the environment variables that get setup
   in my login shells.  In particular, the [[https://github.com/caldwell/build-emacs/blob/master/launch.rb][emacs launcher script]] from [[https://emacsformacosx.com/][GNU Emacs for Mac OS X]] sets PATH well.

** zsh Shell Support

   I have been a zsh user for some time, but I also maintain a reasonable bash setup.  In this config, I
   expect to add support for zsh idioms over time, especially as [[https://www.theverge.com/2019/6/4/18651872/apple-macos-catalina-zsh-bash-shell-replacement-features][zsh is the default shell on MacOS
   Catalina]].

* Record Startup Timing

  Record the elapsed time of starting up emacs.

  My /classic/ configuration took about 2.1 seconds to load.

  #+BEGIN_SRC emacs-lisp
    (defconst emacs-start-time (current-time))

    (unless noninteractive
      (message "Loading %s..." load-file-name))
  #+END_SRC

* General Settings
** Emacs Directories

   I prefer Howard's style of [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#my-directory-location][defining where to store eveything]], so I shamelessly stole it.

   #+BEGIN_SRC emacs-lisp
     (defconst jwm/emacs-directory (concat (getenv "HOME") "/.emacs.d"))

     (defun jwm/emacs-subdirectory (d) (expand-file-name d jwm/emacs-directory))

     ;; initialize some directories if needed
     (let* ((subdirs '("elisp" "backups"))
            (fulldirs (mapcar (lambda (d) (jwm/emacs-subdirectory d)) subdirs)))
       (dolist (dir fulldirs)
         (when (not (file-exists-p dir))
           (message "Make directory: %s" dir)
           (make-directory dir))))
   #+END_SRC

** Custom Settings

   Explicitly store and load my custom settings.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "settings.el" jwm/emacs-directory))
     (when (file-exists-p custom-file)
       (load custom-file t))
   #+END_SRC

** Helpful Predicates

   Some useful predicates in customization...

   #+BEGIN_SRC emacs-lisp
     (defun jwm/mac-p ()
       (and (eq 'ns (window-system))
            (eq 'darwin system-type)))

     (defun jwm/personal-mac-p ()
       (and (jwm/mac-p)
            (file-exists-p (concat (getenv "HOME") "/jdocs"))))

     (defun jwm/sift-mac-p ()
       (and (jwm/mac-p)
            (file-exists-p (expand-file-name "~/code/java/build.gradle"))))
   #+END_SRC

** Modernizing Emacs

   Another section I lifted [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#modernizing-emacs][straight from Howard]].  The description is his text.

   #+begin_quote
     With a long history of working on small machines without gigabytes
     of RAM, we might as well let Emacs be the beast it has always
     dreamed.

     First, let’s increase the cache before starting garbage collection:
   #+end_quote

   #+BEGIN_SRC elisp
     (setq gc-cons-threshold 50000000)
   #+END_SRC

   #+begin_quote
     Found [[https://github.com/wasamasa/dotemacs/blob/master/init.org#init][here]] how to remove the warnings from the GnuTLS library when
     using HTTPS... increase the minimum prime bits size:
   #+end_quote

   #+BEGIN_SRC elisp
     (setq gnutls-min-prime-bits 4096)
   #+END_SRC

** Personal Information

   #+BEGIN_SRC emacs-lisp
     (setq user-full-name "Jeff McCarrell"
           user-mail-address (cond
                              ((jwm/sift-mac-p) "jmccarrell@siftscience.com")
                              (t "jeff@mccarrell.org")))
   #+END_SRC
** Emacs Server and PATH.

   Start emacs server on my main windowed emacs.

   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (server-start))
   #+END_SRC

   I considered using =exec-path-from-shell=, but some experimentation shows that the only added benefit I
   get is to set MANPATH.  At the moment, I don't consider that enough of a win.

   =exec-path= is reasonably set by my usual method of invoking emacs from iTerm, which also benefits from
   the [[https://github.com/caldwell/build-emacs/blob/master/launch.rb][emacs ruby launcher script]] from [[https://emacsformacosx.com/][GNU Emacs for Mac OS X]].

   #+BEGIN_SRC emacs-lisp :tangle no
     exec-path
     ;; =>
     ("/usr/local/bin" "/usr/bin" "/bin" "/usr/sbin" "/sbin" "/Users/jeff/.pyenv/shims" "/Users/jeff/bin"
      "/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_14"
      "/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_14"
      "/Applications/Emacs.app/Contents/MacOS/libexec"
      "/Applications/Emacs.app/Contents/MacOS/bin")
   #+END_SRC

   Here is what I see from =exec-path-from-shell=

   #+BEGIN_SRC emacs-lisp :tangle no
     (exec-path-from-shell-initialize)
     ;; =>
     (("MANPATH" . "/usr/share/man:/usr/local/share/man:/Library/TeX/Distributions/.DefaultTeX/Contents/Man:/usr/local/opt/coreutils/libexec/gnuman")
      ("PATH" . "/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/jeff/.pyenv/shims:/Users/jeff/bin"))
   #+END_SRC

   which is not sufficiently better IMO.

* Package Initialization
** Package Manager

   Ensure the org repository and melpa are searched for packages.

   #+BEGIN_SRC emacs-lisp
     (require 'package)

     (unless (assoc-default "org" package-archives)
       (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))
     (unless (assoc-default "melpa" package-archives)
       (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))

     (package-initialize)
   #+END_SRC

   Use =M-x package-refresh-contents= to reload the list of packages as needed.

** Use-Package

   Prefer [[https://github.com/jwiegley/use-package][use-package]] more or less as a more convenient way of customizing emacs. It does a whole lot more
   than that. My usage is fairly shallow.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-install 'use-package))

     (setq use-package-verbose t)
     (setq use-package-always-ensure t)

     (require 'use-package)
   #+END_SRC

** Howard's Recommended Emacs Lisp Libs

   Again [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#init-file-support][following Howard here]]. Add in these supporting libraries to ease emacs lisp development. [[https://github.com/magnars/dash.el][dash]] for a
   modern list api, [[https://github.com/magnars/s.el][s]] for string manipulation, and [[https://github.com/rejeep/f.el][f]] for file manipulation.

   #+BEGIN_SRC emacs-lisp
     (use-package dash
       :config (eval-after-load "dash" '(dash-enable-font-lock)))

     (use-package s)

     (use-package f)
   #+END_SRC

* Variables
** Prefer Minimal Emacs

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
     ;; needed for emacs23
     (setq inhibit-splash-screen t)
     (setq initial-scratch-message "")

     ;; Don't beep at me
     (setq visible-bell t)

     ;; get rid of all of the backup files; that is what revision control is for.
     (setq backup-before-writing nil)
     (setq make-backup-files nil)

     ;; screen real estate is for text, not widgets
     (when (window-system)
       (tool-bar-mode 0)
       (when (fboundp 'horizontal-scroll-bar-mode)
         (horizontal-scroll-bar-mode -1))
       (scroll-bar-mode -1))
   #+END_SRC

** Prefer utf8 Everywhere

   Follow Grant's [[https://www.wisdomandwonder.com/article/10775/emacsorg-mode-how-to-probably-configure-everything-for-utf-8-in-emacs][lead here]]

   #+BEGIN_SRC emacs-lisp
     ;; prefer utf-8 encoding in all cases.
     (let ((lang 'utf-8))
       (set-language-environment lang)
       (prefer-coding-system lang))
   #+END_SRC

** Tabs

   I prefer spaces over tabs in all cases.  [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][Source]].  I guess I don't write many Makefiles any more.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2)
   #+END_SRC

   Tab for completion is wired deeply into my emacs-fingers.

   #+BEGIN_SRC emacs-lisp
     (setq-default tab-always-indent 'complete)
   #+END_SRC

** Line Wrapping

   In general, I prefer to see the entire line of text in the window even when it is wider than the frame.
   Thus I prefer [[info:emacs#Visual%20Line%20Mode][Visual Line Mode]].  And, in general, I want emacs to wrap my text for me.  I chose 108 as a
   relatively arbitrary line width value that works well for me.  [[https://en.wikipedia.org/wiki/Punched_card#Hollerith's_early_punched_card_formats][Hollerith cards]] are dead!  Long live
   Hollerith cards.

   #+BEGIN_SRC emacs-lisp
     ;; Hollerith cards have had their day. Norming to 80 characters seems like a poor use of screen real estate
     ;; to me. I can't form a particular argument for 108, other than: it is larger than 72 and seems to fit
     ;; better.
     (setq-default fill-column 108)
     (auto-fill-mode)
     (global-visual-line-mode)
   #+END_SRC

** Terminal and Shell (zsh) Settings

*** Reduce Startup Time for zsh

    I find the battle to keep shell startup time crisp to be never ending.  I have come to regard it in the
    same vein as spring cleaning or maybe dental visits for teeth cleaning: useful, but never my first
    choice.

    As of this writing, my interactive zsh startup times are on the order of 1 second:

    #+BEGIN_EXAMPLE
    ❯ time zsh -i -c exit
    zsh -i -c exit  0.68s user 0.36s system 97% cpu 1.066 total
    #+END_EXAMPLE

    which is too long.  [[https://github.com/abo-abo/swiper/issues/2190#issuecomment-525385066][Especially for counsel-grep]].  So configure the arguments given to zsh by emacs when
    attempting to run processes via =shell-command= and friends to ignore reading initialization files.

    That this works is dependent on already having a reasonable environment configured -- including and most
    especially PATH -- so that we don't *need* to re-execute all of that lovely zsh initialization code
    every time emacs wants to run a process.

**** =-f= is an alias for =-conorcs=

     The following section on =-conorcs= is true, and valid.  In addition, [[http://zsh.sourceforge.net/Doc/Release/Options.html#Default-set][=-f= will suppress reading RC files]]:

     #+begin_example
       -f
         NO_RCS
     #+end_example

**** What is =-conorcs=?

     As described in [[http://zsh.sourceforge.net/Doc/Release/Invocation.html#Invocation-2][zsh invocation]], zsh allows concatenation of single character command line options.  We
     want both
     - =-c=
     - =-o norcs=
     and as a single argument to reduce potential issues with whitespace evaluation at the emacs shell
     boundary.  We can express that as =-conorcs=.

     The intuition about this setting is reinforced by measurement:

     #+BEGIN_EXAMPLE
       M-x shell-command time zsh -onorcsc exit
       zsh -onorcsc exit  0.00s user 0.00s system 69% cpu 0.004 total
     #+END_EXAMPLE

     and

     #+begin_example
       M-x shell-command time zsh -cf exit
       zsh -f -c exit  0.00s user 0.00s system 64% cpu 0.006 total
     #+end_example

     Which leads to:

     #+BEGIN_SRC emacs-lisp
       (defun jwm/shell-is-zsh-p ()
         (string-suffix-p "zsh" shell-file-name))

       (when (jwm/shell-is-zsh-p)
         (setq shell-command-switch "-cf"))
     #+END_SRC

**** Effect

    After this setting is in place, response time for emacs executed processes improve, for me by 3 orders
    of magnitude.

    #+BEGIN_EXAMPLE
      M-x shell-command time date
      Sun Mar 29 10:33:10 PDT 2020
      date  0.00s user 0.00s system 66% cpu 0.002 total
    #+END_EXAMPLE

    Your mileage will vary depending on the contents of your zsh dot files.

**** What about =bash=?

     An alternative would be to switch to bash, which from my measurements and current config shows shorter
     startup time.  This difference is no doubt entirely due to my zsh initialization scripts.

     #+BEGIN_EXAMPLE
       M-x shell-command time bash -c exit
       bash -c exit  0.00s user 0.00s system 69% cpu 0.004 total
     #+END_EXAMPLE

** Other Misc Settings

   Various settings I have come to prefer over the years.

   #+BEGIN_SRC emacs-lisp
     ;; always end a file with a newline
     (setq require-final-newline t)

     ;; delete the region when typing, just like as we expect nowadays.
     (delete-selection-mode t)

     ;; highlight the matching parenthesis
     (show-paren-mode t)

     ;; Answering just 'y' or 'n' will do
     (defalias 'yes-or-no-p 'y-or-n-p)

     ;; revert buffers automatically when underlying files are changed externally
     (global-auto-revert-mode t)

     ;; no disabled functions
     (setq disabled-command-function nil)
   #+END_SRC

* Display Settings
** Color Theme

   After much experimentation, I have come to prefer zenburn. Over the years, I have used my own color
   theme, which I used to be quite proud of, and then solarized. Now I have come to prefer zenburn. It works
   well for emacs running in the terminal as well.

   For reference, here is how Sacha overrides and [[file:/t/emacs-configs/sacha-chua-dotemacs/Sacha.org::(defun%20my/setup-color-theme%20()%20(interactive)%20(when%20(display-graphic-p)%20(color-theme-solarized))%20(set-background-color%20"black")%20(set-face-foreground%20'secondary-selection%20"darkblue")%20(set-face-background%20'secondary-selection%20"lightblue")%20(set-face-background%20'font-lock-doc-face%20"black")%20(set-face-foreground%20'font-lock-doc-face%20"wheat")%20(set-face-background%20'font-lock-string-face%20"black"))%20(use-package%20color-theme-solarized%20:config%20(my/setup-color-theme))][customizes her use of solarized]].

   #+BEGIN_SRC emacs-lisp
    (use-package zenburn-theme
      :init (load-theme 'zenburn t))
   #+END_SRC

*** Themes I have experimented with

    First of all, [[https://peach-melpa.org/][peach melba]] is a convenient way to preview themes to try out.

    Mostly to keep myself from repeating work, here is a partial list of themes I have tried and found
    inferior to zenburn, mostly due to their handling of =org-mode=.

    - [[https://peach-melpa.org/themes/monokai-pro-theme][monokai pro]]
    - [[https://peach-melpa.org/themes/gruvbox-theme?lang=el&variant=gruvbox-dark-medium][gruvbox dark medium]]

** Font

   I prefer a little bigger (14 point) font on my personal laptop, especially on my large monitor at home.

   Here is how [[https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el#L7-L33][Xah Lee sets his frame font]]

   And a 2019 [[https://www.wisdomandwonder.com/text/12298/choosing-a-monospace-font-2019-march#more-12298][blog post]] comparing fonts that led me to the font [[https://github.com/source-foundry/Hack][Hack]].  Install Hack via homebrew:

   #+BEGIN_SRC shell
     brew cask install caskroom/fonts/font-hack
   #+END_SRC

   and use it for all frames:

   #+BEGIN_SRC emacs-lisp
     (defun jwm/font-exists-p (f)
       (and (window-system)
            (member f (font-family-list))))

     (when (window-system)
       (let ((preferred-font
              (cond
               ((and (jwm/font-exists-p "Hack") (jwm/mac-p)) "Hack-14")
               (t "Monaco-12"))))
           (message "setting Jeff preferred font %s" preferred-font)
           (set-frame-font preferred-font t t)))
   #+END_SRC

** Diminish

   Manage how minor modes affect the mode line.

   #+begin_src emacs-lisp
     (use-package diminish
       :init (diminish 'visual-line-mode))
   #+end_src

** Whitespace Mode

   This is another [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#whitespace-mode][copy and paste from Howard]]. It makes it easier to see whitespace when necessary.

   #+BEGIN_SRC emacs-lisp
     (use-package whitespace
       :bind ("C-c T w" . whitespace-mode)
       :init
       (setq whitespace-line-column nil
             whitespace-display-mappings '((space-mark 32 [183] [46])
                                           (newline-mark 10 [9166 10])
                                           (tab-mark 9 [9654 9] [92 9])))
       :config
       (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
       (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
       :diminish whitespace-mode)
   #+END_SRC

* Selection
** expand-region

   I have grown to prefer =expand-region=.  This is directly modified/cribbed from Howard's config.

   My usage has not yet grown to benefit from Howard's additions; maybe some day.

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :config
       (defun ha/expand-region (lines)
         "Prefix-oriented wrapper around Magnar's `er/expand-region'.

          Call with LINES equal to 1 (given no prefix), it expands the
          region as normal.  When LINES given a positive number, selects
          the current line and number of lines specified.  When LINES is a
          negative number, selects the current line and the previous lines
          specified.  Select the current line if the LINES prefix is zero."
         (interactive "p")
         (cond ((= lines 1)   (er/expand-region 1))
               ((< lines 0)   (ha/expand-previous-line-as-region lines))
               (t             (ha/expand-next-line-as-region (1+ lines)))))

       (defun ha/expand-next-line-as-region (lines)
         (message "lines = %d" lines)
         (beginning-of-line)
         (set-mark (point))
         (end-of-line lines))

       (defun ha/expand-previous-line-as-region (lines)
         (end-of-line)
         (set-mark (point))
         (beginning-of-line (1+ lines)))

       ;; jwm: however, I can't seem to get C-= from my mac keyboard.
       ;;   so prefer C-@
       :bind ("C-@" . ha/expand-region))
   #+END_SRC

* Window Movement

  I prefer ace-window

  #+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :bind (("M-o" . ace-window))
      :config
      (setq aw-dispatch-always t)
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
  #+END_SRC

  I did experiment with eyebrowse.  However, its default binding =C-c C-w= conflicts with =org-refile=, so
  it had to go.

* Key Bindings
** Option and Command Modifier Keys on a Mac

   Howard maps the option and command keys on mac hardware to different emacs key symbols to allow him that
   many more possible key bindings, like this:

   #+BEGIN_SRC emacs-lisp :tangle no
     (setq mac-option-modifier 'meta)
     (setq mac-command-modifier 'super)
   #+END_SRC

   And I did much the same thing.  However, I think I prefer to keep meta closest to the space bar.

   I leave right-option for the OS X combiner keys, like √ from right-option v.

   And I prefer to switch between emacs frames using the standard mac gesture =Command-`=, although since
   adding =ace-window=, I suppose I need =Command-`= less than before it.

   #+BEGIN_SRC emacs-lisp
     (when (jwm/mac-p)
       (setq mac-command-modifier 'meta)
       (setq mac-option-modifier 'super)
       (setq mac-right-option-modifier 'none)

       ;; mirror the mac user gesture for switching emacs frames
       ;;  this supports my habit of using two emacs frames side by side.
       (bind-key "M-`" 'other-frame)

       ;; prevent my thumb from triggering this menu on the trackpad when in open laptop mode
       ;;  ie, when I am working on the train
       (bind-key [C-down-mouse-1] 'ignore))
   #+END_SRC

** Global Key Bindings

   I really like Howards [[file:/t/emacs-configs/howardabrams-dot-files/emacs-client.org::*Key%20Bindings][global key binding approach]], which leverages John Wiegley's [[https://github.com/jwiegley/use-package/blob/master/bind-key.el][bind-key]] that is part
   of [[https://github.com/jwiegley/use-package/blob/master/bind-key.el][use-package]].

   Recall that there are several /power/ features of =bind-key=, such as rebinding, adding keys to a
   specific map etc. Here are John's [[https://github.com/jwiegley/use-package/blob/master/bind-key.el#L41-L90][pointers]] in the comments of the package.

   #+BEGIN_SRC emacs-lisp
     (bind-keys
      ;; long time bindings I have preferred
      ("C-c u" . revert-buffer)
      ("C-M-g" . goto-line)

      ;; perhaps turn these on when/if I bring in Howards font size functions
      ;; ("s-C-+" . ha/text-scale-frame-increase)
      ;; ("A-C-+" . ha/text-scale-frame-increase)
      ;; ("s-C-=" . ha/text-scale-frame-increase)
      ;; ("A-C-=" . ha/text-scale-frame-increase)
      ;; ("s-C--" . ha/text-scale-frame-decrease)
      ;; ("A-C--" . ha/text-scale-frame-decrease)
      )
   #+END_SRC

** Block wrappers
   Again, I am cribbing this pretty much [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#block-wrappers][straight from Howards' config]]

*** Insert pairs
    #+begin_quote
      While the =M-(= binding to =insert-pair= is great, I often need to wrap with other characters:
    #+end_quote

    But not =M-`= for me; I prefer that to switch frames, as in the os x convention.

    And also, not =M-<= either; I prefer to use that for beginning/end-of-buffer.  I wonder what keybinding
    Howard uses for that?

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "M-[") 'insert-pair)
      (global-set-key (kbd "M-{") 'insert-pair)
      ;; (global-set-key (kbd "M-<") 'insert-pair)
      (global-set-key (kbd "M-'") 'insert-pair)
      ;; (global-set-key (kbd "M-`") 'insert-pair)
      (global-set-key (kbd "M-\"") 'insert-pair)
   #+END_SRC

*** wrap-region

    Quoting Howard:

    #+begin_quote
      But [[https://github.com/rejeep/wrap-region.el][wrap-region]] is even more flexible. In most editors, selecting text and typing anything replaces
      the selected text (see the [[info:emacs#Using%20Region][delete-selection-mode]]), but in this case, we can do something
      different... like wrapping:
    #+end_quote

    #+BEGIN_SRC emacs-lisp
      (use-package wrap-region
        :ensure   t
        :config
        (wrap-region-global-mode t)
        (wrap-region-add-wrappers
         '(("(" ")")
           ("[" "]")
           ("{" "}")
           ("<" ">")
           ("'" "'")
           ("\"" "\"")
           ("‘" "’"   "q")
           ("“" "”"   "Q")
           ("*" "*"   "b"   org-mode)                 ; bolden
           ("*" "*"   "*"   org-mode)                 ; bolden
           ("/" "/"   "i"   org-mode)                 ; italics
           ("/" "/"   "/"   org-mode)                 ; italics
           ("~" "~"   "c"   org-mode)                 ; code
           ("~" "~"   "~"   org-mode)                 ; code
           ("=" "="   "v"   org-mode)                 ; verbatim
           ("=" "="   "="   org-mode)                 ; verbatim
           ("_" "_"   "u" '(org-mode markdown-mode))  ; underline
           ("**" "**" "b"   markdown-mode)            ; bolden
           ("*" "*"   "i"   markdown-mode)            ; italics
           ("`" "`"   "c" '(markdown-mode ruby-mode)) ; code
           ("`" "'"   "c"   lisp-mode)                ; code
           ))
        :diminish wrap-region-mode)
    #+END_SRC

** which-key

   I have come to appreciate the exploration of the key maps that [[https://github.com/justbur/emacs-which-key][which-key]] enables.

   Howard extensively [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#displaying-command-sequences][customizes the display of which-key]]. I find that interesting, and maybe something to
   pursue one day.

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config
       :diminish which-key-mode
       :config

       ;; prefer to show the entire command name with no truncation.
       ;;  some of those projectile command names exceed the default value of 27, eg
       ;;  projectile-toggle-between-implementation-and-test
       (setq which-key-max-description-length nil)
       (which-key-mode 1))
   #+END_SRC

* Hooks
** Whitespace Cleanup Hook

   I want to run ~whitespace-cleanup~ on ~save-buffer~ scoped to specific scopes I manage.  In general, I
   don't want to run it in shared spaces -- especially code spaces -- where rewriting some existing
   whitespace convention might cause unintended changes.

   #+BEGIN_SRC emacs-lisp
     (defvar jwm/run-whitespace-cleanup-on-save-p nil
       "run whitespace-cleanup on buffer-save. set to t where desired in file or directory local scopes.")

     (defun jwm/save-buffer-whitespace-cleanup-hook ()
       "run whitespace-cleanup when enabled by jwm/run-whitespace-cleanup-on-save-p."
       (when jwm/run-whitespace-cleanup-on-save-p
         (whitespace-cleanup)))

     (add-hook 'before-save-hook 'jwm/save-buffer-whitespace-cleanup-hook)
   #+END_SRC

* Dired

  Start simple.  The main keystrokes I want to train my fingers to execute are:

  | keys      | command                 | what it does                                          |
  |-----------+-------------------------+-------------------------------------------------------|
  | C-x d     | dired                   | start dired                                           |
  | C-x C-j   | dired-jump              | Jump to Dired buffer corresponding to current buffer. |
  | C-x 4 C-j | dired-jump-other-window |                                                       |

  This config is copied from bbatsov

  But apparently =dired= is a non-package package -- whatever that means.  So to correct this startup error:

  #+BEGIN_QUOTE
  Error (use-package): Failed to install dired: Package ‘dired-’ is unavailable
  #+END_QUOTE

  I have added =:ensure nil=, following [[https://emacs.stackexchange.com/questions/26810/why-doesnt-use-package-dired-work-for-me][this advice]]

  #+BEGIN_SRC emacs-lisp
    (use-package dired
      :ensure nil
      :config
      ;; dired - reuse current buffer by pressing 'a'
      ;; (put 'dired-find-alternate-file 'disabled nil)

      ;; always delete and copy recursively
      ;; (setq dired-recursive-deletes 'always)
      ;; (setq dired-recursive-copies 'always)

      ;; if there is a dired buffer displayed in the next window, use its
      ;; current subdir, instead of the current subdir of this dired buffer
      (setq dired-dwim-target t)

      ;; enable some really cool extensions like C-x C-j (dired-jump)
      (require 'dired-x))
  #+END_SRC

* Search
** ag

   #+BEGIN_SRC emacs-lisp
     ;; ag config derived from danielmai's config
     (use-package ag
       :commands ag)
   #+END_SRC

** ripgrep

   I get ripgrep as a dependency of =projectile-ripgrep=.  Since I am using (apparently) the bone-stock
   configuration, there is nothing in this section.

* Ivy, Avy, Swiper, Projectile

** Projectile Config

  I choose to pattern my config for these related packages after abo-abo, the author.  Well, it turns out
  abo-abo has a pretty baroque way of loading his configuration.

  So combine the [[https://github.com/bbatsov/emacs.d/blob/master/init.el#L538-L572][approach used by bbatsov]] with that used by [[file:/t/emacs-configs/danielmai-dotemacs/config.org::*Projectile][Daneil's projectile config]].

  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :diminish projectile-mode
      :commands (projectile-mode projectile-switch-project)
      :bind (("C-c p p" . projectile-switch-project)
             ("C-c p s s" . projectile-ag)
             ("C-c p s r" . projectile-ripgrep))
      :init
      (setq projectile-completion-system 'ivy)
      :config
      (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
      (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
      (setq projectile-keymap-prefix (kbd "C-c p"))
      (projectile-global-mode t))
  #+END_SRC

** Counsel Projectile

   #+BEGIN_SRC emacs-lisp
     (use-package counsel-projectile
       :config
       (counsel-projectile-mode))
   #+END_SRC

** Ivy, Counsel, Avy and Swiper Config

   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :diminish (ivy-mode . "")
       :config
       (ivy-mode 1)
       ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
       (setq ivy-use-virtual-buffers t)
       ;; show both the index and count of matching items
       (setq ivy-count-format "%d/%d "))

     (use-package counsel
       :bind (("C-c j" . counsel-git-grep)
              ("C-c k" . counsel-rg)
              ("C-c K" . counsel-ag)))

     (use-package swiper
       :config
       (global-set-key "\C-s" 'swiper))
   #+END_SRC

   this is stolen from [[https://github.com/jwiegley/dot-emacs/blob/master/init.el#L420][jwiegley's config]]
   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :bind* ("C-." . avy-goto-char-timer)
       :config
       (avy-setup-default))
   #+END_SRC

* Git

  I would like to consider [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]] someday.

** Magit

   Indispensible.  One of the two killer apps for emacs IMO, =org-mode= being the other.

   Howard does [[file:/t/emacs-configs/howardabrams-dot-files/emacs.org::*Magit][additional customization]] that I should consider someday.

   My usage is considerably simpler.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :defer t
       :bind ("C-x g" . magit-status))
   #+END_SRC

* Org
** Org Configuration
*** Org Global Key Bindings

    #+BEGIN_SRC emacs-lisp
      (bind-keys
       ;; org mode wants these default global bindings set up.
       ("C-c l" . org-store-link)
       ("C-c c" . org-capture)
       ("C-c a" . org-agenda))
    #+END_SRC

    Circa spring 2020, =C-c b= gives me:
    #+begin_example
      command-execute: Wrong type argument: commandp, org-iswitchb
    #+end_example

    so I have removed that key-binding.

*** Where to Look for Org Info

    #+BEGIN_SRC emacs-lisp
      (setq org-directory
            (cond ((jwm/sift-mac-p) "~/sift/todo")
                  (t "~/jwm/todo")))

      ;; The default place to put notes for capture mode
      (setq org-default-notes-file
            (concat org-directory
                    (cond ((jwm/sift-mac-p) "/sift.org")
                          (t "/todo.org"))))

      ;; where I store periodic reminders, ie, ticklers in GTD-talk
      (defvar jwm/org-tickler-file (concat org-directory "/tickler.org"))
    #+END_SRC

**** Agenda Files

     Recall that if =org-agenda-files= is a single file name, then that symbol names a file which is read
     for the list of agenda files to manage.

     Further, the functions =org-agenda-file-to-front= and =org-remove-file= can be used to manage that list.

     This is the mechanism I want to utilize here.

     #+BEGIN_SRC emacs-lisp
       (setq org-agenda-files (jwm/emacs-subdirectory "org-agenda-files-list"))
     #+END_SRC

*** Templates, Tasks, Refiling

    I lifted the [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.htm][tickler capture entry from Nicolas Petton]].

    #+BEGIN_SRC emacs-lisp
      ;; capture template.
      (setq org-capture-templates
            '(("t" "Todo" entry (file+headline org-default-notes-file "Tasks")
               "* TODO %?\n %t\n  %i\n  %a\n")
              ("T" "Tickler" entry (file+headline jwm/org-tickler-file "Tickler")
               "* %i%?\n %U\n")
              ("j" "Journal" entry (file+datetree "~/pdata/journal.org")
               "* %?\nEntered on %U\n  %i\n  %a\n")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; Jeff task states
      (setq org-todo-keywords
            '((sequence
               "TODO(t)"
               "NEXT(n!)"
               "DOING(g!)"
               "WAITING(w@/!)"
               "|" "DONE(d!)"
               "CANCELLED(c@)"
               "DEFERRED(D@)")))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      ;; I prefer 2 levels of headlines for org refile targets
      ;;  this matches well with my TASKS/PROJECTS high level
      ;; further, I prefer the refiling to be per-buffer, not across all org-agenda-files
      ;;  to preserve context.  most often, I use the file as context.
      (setq org-refile-targets '((nil . (:maxlevel . 2))))
    #+END_SRC

** Save Org Files Periodically

   [[https://github.com/jwiegley/dot-emacs/blob/master/dot-org.el#L242-L249][Stolen from John Weigley]].

   #+BEGIN_SRC emacs-lisp
     (defun save-org-mode-files ()
       (dolist (buf (buffer-list))
         (with-current-buffer buf
           (when (eq major-mode 'org-mode)
             (if (and (buffer-modified-p) (buffer-file-name))
                 (save-buffer))))))

     (run-with-idle-timer 25 t 'save-org-mode-files)
   #+END_SRC

** Org babel

   I stole much of this from [[https://github.com/danielmai/.emacs.d/blob/master/config.org#org-babel-languages][Daniel Mai]].

   #+BEGIN_SRC emacs-lisp
     (use-package ob-restclient)

     (org-babel-do-load-languages
      'org-babel-load-languages
      '((python . t)
        (C . t)
        (calc . t)
        (java . t)
        (ruby . t)
        (lisp . t)
        (scheme . t)
        (shell . t)
        (sql . t)
        (sqlite . t)
        (js . t)
        (restclient . t)))

     (defun my-org-confirm-babel-evaluate (lang body)
       "Do not confirm evaluation for these languages."
       (not (or (string= lang "C")
                (string= lang "java")
                (string= lang "python")
                (string= lang "emacs-lisp")
                (string= lang "sql")
                (string= lang "sqlite"))))
     (setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
   #+END_SRC

*** prefer python3

    Circa fall 2019 as python2 heads towards its final deprecation date, I want to prefer =python3= over
    =python2= in all cases.  So start with ob.

    #+BEGIN_SRC emacs-lisp
      (setq org-babel-python-command "python3")
    #+END_SRC

* Programming Support
** yasnippets

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :config
       (use-package yasnippet-snippets)
       (yas-reload-all)
       (add-hook 'prog-mode-hook #'yas-minor-mode)
       (add-hook 'org-mode-hook #'yas-minor-mode))
   #+END_SRC

   #+begin_src emacs-lisp
     (use-package auto-yasnippet
       :after yasnippet
       :bind (("s-w" . aya-create)
              ("s-y" . aya-expand)))
   #+end_src

** WIP C Style

   According to cc-styles.el, the function =c-add-style= is the preferred way to define C style.

   #+BEGIN_QUOTE
     Use the function =c-add-style= to add new styles or modify existing styles (it is not a good idea to
     modify existing styles -- you should create a new style that inherits the existing style).
   #+END_QUOTE

   Here is the [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Adding-Styles.html][GNU manual on adding styles]].

   Clearly, more to do here.

** crux

   I use bbatsov's [[https://github.com/bbatsov/crux][crux]] at times, especially =C-c n=.

   #+BEGIN_SRC emacs-lisp
     (use-package crux
       :bind
       (
        ("C-c n" . crux-cleanup-buffer-or-region)
        ;; ("C-S-RET" . crux-smart-open-line-above)
        ;; ("M-o" . crux-smart-open-line)
        ("C-c d" . crux-duplicate-current-line-or-region)
        ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)
        ("C-c C-r" . crux-rename-file-and-buffer)))
   #+END_SRC

** js2 and json mode

   I lifted this straight from Howard's config.  Not that I write much javascript.

   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       :init
       (setq-default js-indent-level 2
                     js2-global-externs (list "window" "module" "require" "buster" "sinon" "assert" "refute" "setTimeout" "clearTimeout" "setInterval" "clearInterval" "location" "__dirname" "console" "JSON" "jQuery" "$"))
       (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
       (add-to-list 'auto-mode-alist '("\\.es6$" . js2-mode)))

   #+END_SRC

   I spend more time dealing with various blobs of json, so follow the lead of [[http://develop.spacemacs.org/layers/+lang/json/README.html][spacemacs]] for [[https://github.com/joshwnj/json-mode][json-mode]].

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode)
   #+END_SRC

** python

   Prefer python3 in all cases.
   This work presumes apriori that brew has installed python3 as the mac os python3 does not support readline.

   #+begin_example
     brew install python3
   #+end_example

   #+begin_src emacs-lisp
     (setq  python-shell-interpreter "python3")
   #+end_src

   Lets try elpy stock and see what happens.  So far, so good.

   I did run into a wrinkle preferring python3 over python2.  As usual, it comes at the conjunction of
   several systems that make different assumptions about the global run time configuration.

   This comes down to the expectation of [[https://github.com/jorgenschaefer/pyvenv][pyvenv.el]] that virtualenvwrapper is available for emacs to use and
   that the python with virtualenvwrapper installed can be easily identified.

   So help things out by explicitly setting =pyvenv-virtualenvwrapper-python= since pyvenv.el does not
   search for =python3=, just for =python=.

   #+begin_src emacs-lisp
     (use-package elpy
       :init
       (setq pyvenv-virtualenvwrapper-python
             (or (getenv "VIRTUALENVWRAPPER_PYTHON")
                 (executable-find "python3")
                 "python3"))
       (setq elpy-rpc-python-command
             (or (getenv "VIRTUALENVWRAPPER_PYTHON")
                 (executable-find "python3")
                 "python3"))
       (elpy-enable))
   #+end_src

* Integration with the Outside World
** docker and dockerfile
   Surveying my field of emacs devotees for their docker integrations, it seems to me that these two are worthy of study:
   - docker integraton by [[https://github.com/jwiegley/dot-emacs/blob/master/init.el#L1291-L1310][John Wiegley]]
   - and by [[https://github.com/danielmai/.emacs.d/blob/master/config.org#Docker][Daniel Mai]]

   In this case, I am going to follow John Wiegley's approach here.

   I have some reservations about how old docker-compose-mode is, which has not had an update since 2018
   circa summer 2020.  But lets try it and see what happens.

   #+begin_src emacs-lisp
     (use-package docker
       :bind ("C-c d" . docker)
       :diminish)

     (use-package docker-compose-mode
       :mode "docker-compose.*\.yml\\'")

     (use-package docker-tramp
       :after tramp
       :defer 5)

     (use-package dockerfile-mode
       :mode "Dockerfile[a-zA-Z.-]*\\'")
   #+end_src

** atomic-chrome

   #+begin_src emacs-lisp
     (use-package atomic-chrome
       :init
       (ignore-errors
         (atomic-chrome-server-start)))
   #+end_src

   I have had mixed experience with =atomic-chrome=.  It works just fine on my personal mac, where I don't
   particularly need it.  Nothing happens with the same configuration on my work mac, where I would use it
   every day to interact with github if I could, presumably because of the added security gunk my employer
   runs on the hardware they loan me to use.  So =atomic-chrome= has been a /kiss from your sister/ kind of
   deal.

   I will leave it enabled in the hope that I will find a use case for it in my personal work.

* Report Startup Timing

  [[https://github.com/jwiegley/dot-emacs/blob/master/init.el#L4095-L4105][from John Weigley]].

  #+BEGIN_SRC emacs-lisp
    ;;; Post initialization

    (let ((elapsed (float-time (time-subtract (current-time)
                                              emacs-start-time))))
      (message "Loading %s...done (%.3fs)" load-file-name elapsed))

    (add-hook 'after-init-hook
              `(lambda ()
                 (let ((elapsed (float-time (time-subtract (current-time)
                                                           emacs-start-time))))
                   (message "Loading %s...done (%.3fs) [after-init]"
                            ,load-file-name elapsed)))
              t)
  #+END_SRC
